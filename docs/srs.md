# Спецификация проектов Scanf и Printf

## Версия 0.0.1

## 1. Глоссарий

| Термин             | Определение                                                                                                                                                                                                                                                   |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| FreeRTOS           | Операционная система реального времени с поддержкой многозадачности.                                                                                                                                                                                          |
| Трассировка        | Процесс сбора информации о событиях, происходящих в системе во время выполнения программы.                                                                                                                                                                    |
| Трассировочный хук | Функция обратного вызова, активируемая ядром при наступлении события. Подробнее с механизмом трассировки FreeRTOS можно ознакомиться в [официальной документации](https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/09-RTOS-trace-feature). |
| Scanf              | Библиотека для сбора трассировочных данных в FreeRTOS.                                                                                                                                                                                                        |
| Printf             | Инструмент для анализа и визуализации трассировочных данных, собранных с помощью **Scanf**.                                                                                                                                                                   |
| Трейс-лог          | Журнал, содержащий последовательность трассировочных событий системы.                                                                                                                                                                                         |
| Jupyter Notebook   | Интерактивная среда для анализа и визуализации данных с использованием Python.                                                                                                                                                                                |

## 2. Обзор

FreeRTOS предоставляет механизмы многозадачности в реальном времени, что дает множество преимуществ, но также добавляет сложность при разработке. Одним из ключевых аспектов является анализ взаимодействий задач во время выполнения.

Визуальная трассировка позволяет:

- Наглядно оценить работу программы.
- Выявлять проблемы на высоком уровне.
- Анализировать последовательность событий в деталях.

Проекты **Scanf** и **Printf** обеспечивают сбор, обработку и визуализацию трассировочных данных, упрощая процесс отладки многозадачных приложений на FreeRTOS.

## 3. Scanf

Ядро FreeRTOS содержит более 100 трассировочных хуков для регистрации значимых событий во время работы системы. **Scanf** — это header-only библиотека, определяющая эти хуки и сохраняющая информацию о событиях трассировки.

### 3.1 Функциональные требования

- Возможность включать и выключать трассировку.
- Сохранение записей трассировки в память с возможностью определения способа их хранения и передачи.
- Фиксация событий:
  - Выбор задачи для исполнения (**traceTASK\_SWITCHED\_IN**).
  - Снятие задачи с исполнения (**traceTASK\_SWITCHED\_OUT**).
- Включение в трассировку следующей информации:
  - Время начала события.
  - Идентификатор задачи.
  - Тип события.

### 3.2 Нефункциональные требования

- Явная аллокация памяти.
- Подключение **Scanf** не должно требовать модификации ядра FreeRTOS.
- Простая интеграция: достаточно включения `scanf.h` в файл конфигурации FreeRTOS.
- Потокобезопасность.
- Минимальное влияние на производительность системы.

### 3.3 API

```c
typedef struct {
    uint64_t timestamp;
    uint64_t task_id;
    uint16_t event_type;
} SCANF_TraceMessage;

typedef struct {
    size_t count;
    size_t capacity;
    SCANF_TraceMessage* messages;
} SCANF_TraceLog;

typedef void (*trace_log_overflow_handler_t)(SCANF_TraceLog*);

typedef int (*trace_log_save_handler_t)(SCANF_TraceLog*);

/// Инициализация глобального журнала трассировки с заданной ёмкостью.
/// Выделяет в куче log_capacity * sizeof(SCANF_TraceMessage) байт с помощью pvPortMalloc().
///
/// Код возврата: 0 - ок, 1 - вызов pvPortMalloc() вернул ошибку, 2 - трейс-лог уже был инициализирован.
int SCANF_INIT(size_t log_capacity);

/// Регистрация обработчика переполнения трейс-лога.
/// Перед вызовом обработчика трассировка будет остановлена.
int SCANF_SET_OVERFLOW_HANDLER(trace_log_overflow_handler_t* overflow_handler);

/// Освобождает память, выделенную в SCANF_INIT.
/// После этого можно снова безопасно вызвать SCANF_INIT.
void SCANF_DEINIT(size_t log_capacity);

/// Сброс размера журнала трассировки.
void SCANF_RESET();

/// Начало трассировки.
void SCANF_START_TRACING();

/// Остановка трассировки.
void SCANF_STOP_TRACING();

/// Сохранение журнала трассировки с использованием переданного обработчика.
/// Перед вызовом трассировка должка быть остановлена.
///
/// Код возврата: -1 - функция вызвана при включенной трассировке. Иначе значение, возвращенное save_handler.
int SCANF_SAVE(trace_log_save_handler_t save_handler);
```

**Пример использования:**
```c
int save_handler(SCANF_TraceLog* log) {
    FILE* fd = fopen("trace.bin", "a");
    fwrite(log->messages, sizeof(SCANF_TraceMessage), size_t n, fd);
    fclose(fd);
    return 0;
}

void overflow_handler(SCANF_TraceLog* log) {
    if (SCANF_SAVE(save_handler) != 0) {
        printf("Failed to save trace log\n");
    }
    SCANF_RESET();
    SCANF_START_TRACING();
}

int main() {
    if (SCANF_INIT(100) != 0) {
        printf("Failed to initialize trace log\n");
        return 1;
    }

    SCANF_SET_OVERFLOW_HANDLER(overflow_handler);
    SCANF_START_TRACING();

    SCANF_STOP_TRACING();

    if (SCANF_SAVE(save_handler) != 0) {
        printf("Failed to save trace log\n");
    }

    SCANF_DEINIT();
    return 0;
}
```

### 3.4 Желаемый функционал будущих версий

- Поддержка дополнительных событий задач.
- Трассировка событий других сущностей (очередей, таймеров и т. д.).
- Реализация базовых методов сохранения журнала трассировки (TCP, UART, FAT).

## 4. Printf

**Printf** — это инструмент анализа и визуализации трассировочных данных, собранных при помощи **Scanf**.
Текущая реализация представляет собой Jupyter Notebook для обработки и визуального отображения данных.

### 4.1 Функциональные требования

- Работа с файлами, содержащими бинарный журнал трассировки в формате **Scanf**.
- Визуальное отображение исполнения задач на временной диаграмме, где должны присутствовать:
  - Все зарегистрированные задачи.
  - Состояние задач в определённый временной период.

### 4.2 Нефункциональные требования

- Кроссплатформенность (MacOS, Windows, Linux).

### 4.3 Желаемый функционал будущих версий

- Поддержка различных типов событий.
- Группировка событий по видам сущностей (задачи, очереди и т. д.).
- Перенос на полноценное десктопное или веб-приложение.
- Интеграция со средствами отладки для удобной выгрузки журнала трассировки.
